# sqlstride/adapters/postgres.py
import subprocess

from etl.database.sql_dialects import postgres
from sqlalchemy import PoolProxiedConnection
from sqlstride.database.connector_proxy import build_connector

from .base import BaseAdapter
from ..database_object import DatabaseObject


class PostgresAdapter(BaseAdapter):
    dialect = postgres

    def __init__(self, config):
        connection: PoolProxiedConnection = build_connector(config).to_user_postgres()
        super().__init__(connection, config.default_schema, config.log_table, config.lock_table)

    def discover_objects(self):
        cur = self.cursor
        # Tables via pg_dump
        cur.execute("""
                    SELECT table_schema, table_name
                    FROM information_schema.tables
                    WHERE table_type = 'BASE TABLE'
                      AND table_schema NOT IN ('pg_catalog', 'information_schema');
                    """)
        for schema, table in cur.fetchall():
            ddl_query = f"""
/* -------------------------------------------
   DDL generator for test_schema.test_jinja
------------------------------------------- */
WITH cols AS (SELECT c.table_schema,
                     c.table_name,
                     c.ordinal_position,

                  /* complete column-definition text */
                     FORMAT(
                             '%I %s%s%s%s',
                             c.column_name, -- column name
                     /* data type */
                             CASE
                                 WHEN c.data_type IN ('character', 'character varying')
                                     THEN 'varchar(' || c.character_maximum_length || ')'
                                 WHEN c.data_type IN ('numeric', 'decimal')
                                     THEN c.data_type || '(' || c.numeric_precision || ',' || c.numeric_scale || ')'
                                 ELSE c.data_type
                                 END,
                         /* identity / serial */
                             CASE
                                 WHEN pg_get_serial_sequence(
                                         FORMAT('%I.%I', c.table_schema, c.table_name), -- qualified table
                                         c.column_name
                                      ) IS NOT NULL
                                     THEN ' GENERATED BY DEFAULT AS IDENTITY'
                                 ELSE ''
                                 END,
                         /* default value */
                             CASE
                                 WHEN c.column_default IS NOT NULL
                                     THEN ' DEFAULT ' || c.column_default
                                 ELSE ''
                                 END,
                         /* nullability */
                             CASE
                                 WHEN c.is_nullable = 'NO'
                                     THEN ' NOT NULL'
                                 ELSE ''
                                 END
                     ) AS col_ddl
              FROM information_schema.columns AS c
              WHERE c.table_schema = '{schema}'
                AND c.table_name = '{table}'),

     pk AS (SELECT tc.table_schema,
                   tc.table_name,
                   FORMAT(
                           'CONSTRAINT %I PRIMARY KEY (%s)',
                           tc.constraint_name,
                           STRING_AGG(kcu.column_name, ', ' ORDER BY kcu.ordinal_position)
                   ) AS pk_ddl
            FROM information_schema.table_constraints AS tc
                     JOIN information_schema.key_column_usage AS kcu
                          ON tc.constraint_name = kcu.constraint_name
                              AND tc.table_schema = kcu.table_schema
                              AND tc.table_name = kcu.table_name
            WHERE tc.constraint_type = 'PRIMARY KEY'
              AND tc.table_schema = '{schema}'
              AND tc.table_name = '{table}'
            GROUP BY tc.table_schema, tc.table_name, tc.constraint_name)

SELECT FORMAT(
               'CREATE TABLE IF NOT EXISTS %I.%I (\n    %s%s\n);',
               c.table_schema,
               c.table_name,
           /* columns */
               STRING_AGG(c.col_ddl, ',\n    ' ORDER BY c.ordinal_position),
           /* primary key clause, if any */
               COALESCE(E',\n    ' || pk.pk_ddl, '')
       ) AS ddl
FROM cols AS c
         LEFT JOIN pk
                   ON pk.table_schema = c.table_schema
                       AND pk.table_name = c.table_name
GROUP BY c.table_schema, c.table_name, pk.pk_ddl;
                   """
            cur.execute(ddl_query)

            ddl, = cur.fetchone()          # returns the generated DDL string
            yield DatabaseObject("table", schema, table, ddl)

        # Views
        cur.execute("""
                    SELECT table_schema,
                           table_name,
                           pg_get_viewdef(format('%I.%I', table_schema, table_name)::regclass, true)
                    FROM information_schema.views
                    WHERE table_schema NOT IN ('pg_catalog', 'information_schema');
                    """)
        for schema, view, ddl in cur.fetchall():
            yield DatabaseObject("view", schema, view,
                                 f"CREATE OR REPLACE VIEW {schema}.{view} AS\n{ddl};")

        # Functions
        cur.execute("""
                    SELECT n.nspname AS schema_name,
                           p.proname AS function_name,
                           pg_get_functiondef(p.oid) AS function_def
                    FROM pg_proc p
                    JOIN pg_namespace n ON p.pronamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND p.prokind = 'f';
                    """)
        for schema, function_name, ddl in cur.fetchall():
            yield DatabaseObject("function", schema, function_name, ddl)

        # Procedures
        cur.execute("""
                    SELECT n.nspname           AS schema_name,
       p.proname           AS procedure_name,
       pg_get_function_identity_arguments(p.oid) AS arg_signature,
       pg_get_functiondef(p.oid)                 AS procedure_def
FROM   pg_proc      AS p
JOIN   pg_namespace AS n ON n.oid = p.pronamespace
WHERE  p.prokind = 'p'                         -- procedures only
  AND  n.nspname !~ '^pg_'                     -- exclude all pg_* schemas
  AND  n.nspname NOT IN ('information_schema') -- still exclude explicitly
  -- optional language / visibility / extension filters here
ORDER  BY n.nspname, p.proname, arg_signature;
                    """)
        for schema, procedure_name, ddl in cur.fetchall():
            yield DatabaseObject("procedure", schema, procedure_name, ddl)

        # Triggers
        cur.execute("""
                    SELECT 
                        n.nspname AS schema_name,
                        t.tgname AS trigger_name,
                        pg_get_triggerdef(t.oid) AS trigger_def
                    FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND NOT t.tgisinternal;
                    """)
        for schema, trigger_name, ddl in cur.fetchall():
            yield DatabaseObject("trigger", schema, trigger_name, ddl)

        # Types (domains, enums, composite types)
        cur.execute("""
                    SELECT 
                        n.nspname AS schema_name,
                        t.typname AS type_name,
                        pg_catalog.format_type(t.oid, NULL) AS type_def,
                        CASE 
                            WHEN t.typtype = 'd' THEN 'domain'
                            WHEN t.typtype = 'e' THEN 'enum'
                            WHEN t.typtype = 'c' THEN 'composite'
                            ELSE 'type'
                        END AS type_kind
                    FROM pg_type t
                    JOIN pg_namespace n ON t.typnamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND (t.typtype = 'd' OR t.typtype = 'e' OR t.typtype = 'c')
                    AND t.typname NOT LIKE '%\_%';
                    """)
        for schema, type_name, type_def, type_kind in cur.fetchall():
            # For enums, we need to get the enum values
            if type_kind == 'enum':
                cur.execute(f"""
                            SELECT 
                                string_agg(quote_literal(enumlabel), ', ' ORDER BY enumsortorder) AS enum_values
                            FROM pg_enum
                            WHERE enumtypid = '{schema}.{type_name}'::regtype::oid;
                            """)
                enum_values, = cur.fetchone()
                ddl = f"CREATE TYPE {schema}.{type_name} AS ENUM ({enum_values});"
            # For domains, we need to get the domain definition
            elif type_kind == 'domain':
                cur.execute(f"""
                            SELECT 
                                format_type(t.typbasetype, t.typtypmod) AS base_type,
                                t.typdefault AS default_value,
                                t.typnotnull AS not_null,
                                c.consrc AS check_constraint
                            FROM pg_type t
                            LEFT JOIN pg_constraint c ON t.oid = c.contypid
                            WHERE t.typname = '{type_name}'
                            AND t.typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{schema}');
                            """)
                base_type, default_value, not_null, check_constraint = cur.fetchone()
                ddl = f"CREATE DOMAIN {schema}.{type_name} AS {base_type}"
                if default_value:
                    ddl += f" DEFAULT {default_value}"
                if not_null:
                    ddl += " NOT NULL"
                if check_constraint:
                    ddl += f" CHECK ({check_constraint})"
                ddl += ";"
            # For composite types, we need to get the attribute definitions
            elif type_kind == 'composite':
                cur.execute(f"""
                            SELECT 
                                string_agg(attname || ' ' || format_type(atttypid, atttypmod), ', ' ORDER BY attnum) AS attributes
                            FROM pg_attribute
                            WHERE attrelid = '{schema}.{type_name}'::regtype::oid
                            AND attnum > 0
                            AND NOT attisdropped;
                            """)
                attributes, = cur.fetchone()
                ddl = f"CREATE TYPE {schema}.{type_name} AS ({attributes});"
            else:
                ddl = f"-- Type definition for {schema}.{type_name} not implemented"

            yield DatabaseObject("type", schema, type_name, ddl)

        # Materialized Views
        cur.execute("""
                    SELECT 
                        n.nspname AS schema_name,
                        c.relname AS matview_name,
                        pg_get_viewdef(c.oid) AS matview_def
                    FROM pg_class c
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND c.relkind = 'm';
                    """)
        for schema, matview_name, ddl in cur.fetchall():
            yield DatabaseObject("materialized_view", schema, matview_name, 
                                f"CREATE MATERIALIZED VIEW {schema}.{matview_name} AS\n{ddl};")